import 'dart:async';
import 'dart:html' as html;
import 'dart:js' as js;
import 'dart:js_util' as js_util;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;

void main() {
  runApp(const MyApp());
}

const String SERVER_BASE = String.fromEnvironment('SERVER_BASE', defaultValue: 'http://localhost:3000');

class ChatMessage {
  final String sender;
  final String text;
  final bool isSystem;
  final DateTime timestamp;

  ChatMessage({
    required this.sender,
    required this.text,
    this.isSystem = false,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'HearAll',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  // Controllers
  final TextEditingController roomController = TextEditingController();
  final TextEditingController nameController = TextEditingController();
  final TextEditingController inputController = TextEditingController();
  final ScrollController transcriptController = ScrollController();
  final ScrollController diagnosticController = ScrollController();

  // State variables
  bool joined = false;
  bool joining = false;
  bool micOn = false;
  bool isRecording = false;
  bool audioPermissionGranted = false;
  bool hasRequestedMicPermission = false;
  bool showDiagnosticPanel = false;
  
  // Data lists
  List<String> transcriptLines = [];
  List<String> diagnosticLogs = [];
  List<String> participants = [];
  List<ChatMessage> messages = [];

  // WebRTC objects
  dynamic webrtcConn;
  dynamic ttsHandler;

  @override
  void initState() {
    super.initState();
    
    // Register JavaScript callbacks
    _registerJsCallbacks();
    
    // Request microphone permission on load
    _requestMicPermissionOnStartup();
    _initializeWebRTC();
    
    // Verify JavaScript files are loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _verifyJavaScriptLoaded();
    });
  }
  
  void _registerJsCallbacks() {
    // Register connection established callback
    js.context['dartConnectionEstablished'] = () {
      setState(() {
        joined = true;
        joining = false;
      });
      _addDiagnosticLog('[system] Connection established');
      _addTranscriptMessage('[system] Connected to chat room');
    };
    
    // Register connection closed callback
    js.context['dartConnectionClosed'] = () {
      setState(() {
        joined = false;
        joining = false;
        micOn = false;
        participants.clear();
      });
      _addDiagnosticLog('[system] Connection closed');
      _addTranscriptMessage('[system] Disconnected from chat room');
    };
    
    // Register participant update callback
    js.context['dartUpdateParticipants'] = (dynamic participantList) {
      final List<String> newParticipants = List<String>.from(participantList);
      setState(() {
        participants = newParticipants;
      });
      _addDiagnosticLog('[webrtc] Participants updated: ${participants.join(', ')}');
    };
  }

  Future<void> _initializeWebRTC() async {
    try {
      ttsHandler = js_util.callConstructor(
        js_util.getProperty(html.window, 'TTSHandler'),
        [SERVER_BASE]
      );
      _addDiagnosticLog('[system] Audio systems initialized.');
    } catch (e) {
      _addDiagnosticLog('[error] Failed to initialize audio: $e');
    }
  }

  void _addLog(String message, {bool isDiagnostic = false}) {
    setState(() {
      final timestamp = DateTime.now().toString().split('.')[0];
      final logLine = '$timestamp: $message';
      if (isDiagnostic) {
        diagnosticLogs.add(logLine);
      } else {
        transcriptLines.add(logLine);
      }
    });
    
    // Auto-scroll to bottom
    if (isDiagnostic) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (diagnosticController.hasClients) {
          diagnosticController.animateTo(
            diagnosticController.position.maxScrollExtent,
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        }
      });
    } else {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (transcriptController.hasClients) {
          transcriptController.animateTo(
            transcriptController.position.maxScrollExtent,
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        }
      });
    }
  }

  void _addTranscriptMessage(String message) => _addLog(message);
  void _addDiagnosticLog(String message) => _addLog(message, isDiagnostic: true);

  Future<void> _joinRoom() async {
    if (roomController.text.isEmpty || nameController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter both room ID and name')),
      );
      return;
    }

    if (!audioPermissionGranted) {
      _addDiagnosticLog('[error] Join failed: Microphone permission not granted.');
      _requestMicPermissionOnStartup();
      return;
    }

    setState(() {
      joining = true;
    });
    
    try {
      // First check if the server is reachable
      try {
        final response = await http.get(Uri.parse('$SERVER_BASE/'));
        _addDiagnosticLog('[server] Connection test: ${response.statusCode == 200 ? "OK" : "Failed: ${response.statusCode}"}');
      } catch (e) {
        _addDiagnosticLog('[error] Server connection failed: $e');
        _addTranscriptMessage('[error] Could not connect to server. Is it running?');
        setState(() {
          joining = false;
        });
        return;
      }
      
      _addDiagnosticLog('[webrtc] Attempting to join room: ${roomController.text}');
      
      // Make sure the JavaScript function is available
      if (!js.context.hasProperty('webrtcJoin')) {
        _addDiagnosticLog('[error] webrtcJoin function not found');
        _addTranscriptMessage('[error] WebRTC helper not loaded. Please check the console.');
        setState(() {
          joining = false;
        });
        return;
      }
      
      // Use JavaScript interop with the global webrtcJoin function
      try {
        final result = js.context.callMethod('webrtcJoin', [
          roomController.text,
          nameController.text
        ]);
        
        _addDiagnosticLog('[webrtc] Join attempt result: $result');
        
        if (result == null || result == false) {
          _addDiagnosticLog('[error] webrtcJoin failed');
          _addTranscriptMessage('[error] Failed to join room. Check console for details.');
          setState(() {
            joining = false;
          });
          return;
        }
        
        // The onStateChange callback will be handled by dartConnectionEstablished function
        _addTranscriptMessage('[system] Joining room ${roomController.text}... please wait');
      } catch (e) {
        _addDiagnosticLog('[error] Exception calling webrtcJoin: $e');
        _addTranscriptMessage('[error] Failed to join room: $e');
        setState(() {
          joining = false;
        });
        return;
      }
    } catch (e) {
      _addDiagnosticLog('[error] Join room error: $e');
      setState(() {
        joining = false;
      });
    }
  }

  Future<void> _leaveRoom() async {
    setState(() {
      joining = true;
    });
    
    try {
      _addDiagnosticLog('[webrtc] Attempting to leave room');
      
      if (!js.context.hasProperty('webrtcLeave')) {
        _addDiagnosticLog('[error] webrtcLeave function not found');
        _addTranscriptMessage('[error] WebRTC helper not loaded. Disconnecting locally.');
        setState(() {
          joined = false;
          joining = false;
          micOn = false;
        });
        return;
      }
      
      final result = js.context.callMethod('webrtcLeave', []);
      _addDiagnosticLog('[webrtc] Leave result: $result');
      
      // The connection closed callback will handle the state updates
      
    } catch (e) {
      _addDiagnosticLog('[error] Error leaving room: $e');
      _addTranscriptMessage('[error] Error leaving room: $e');
      setState(() {
        joining = false;
      });
    }
  }

  Future<void> _toggleMic() async {
    try {
      final result = js.context.callMethod('webrtcToggleMic', []);
      setState(() {
        micOn = result == true;
      });
      _addDiagnosticLog('[webrtc] Mic toggled: $micOn');
    } catch (e) {
      _addDiagnosticLog('[error] Failed to toggle mic: $e');
    }
  }

  Future<void> _sendMessage() async {
    final text = inputController.text.trim();
    if (text.isEmpty) return;
    
    try {
      _addDiagnosticLog('[webrtc] Sending message');
      js.context.callMethod('webrtcSendText', [text]);
      inputController.clear();
      
      // The message will be echoed back via the message handler
    } catch (e) {
      _addDiagnosticLog('[error] Failed to send message: $e');
    }
  }

  Future<void> _requestMicPermissionOnStartup() async {
    if (hasRequestedMicPermission) return;
    hasRequestedMicPermission = true;
    
    try {
      final stream = await html.window.navigator.mediaDevices?.getUserMedia({'audio': true});
      if (stream != null) {
        _addDiagnosticLog('[system] Microphone access granted');
        setState(() {
          audioPermissionGranted = true;
        });
        
        // Clean up the stream since we don't need it yet
        for (final track in stream.getTracks()) {
          track.stop();
        }
      }
    } catch (e) {
      _addDiagnosticLog('[error] Microphone permission denied: $e');
      setState(() {
        audioPermissionGranted = false;
      });
    }
  }

  Widget _buildSidebarButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    bool isSelected = false,
  }) {
    return Material(
      color: isSelected ? Colors.black.withOpacity(0.2) : Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          child: Row(
            children: [
              Icon(icon, color: Colors.white),
              const SizedBox(width: 12),
              Text(label, style: const TextStyle(color: Colors.white, fontSize: 16)),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainContent() {
    return Expanded(
      flex: 3,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (!joined) ...[
            const Text('Room ID', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            TextField(
              controller: roomController,
              decoration: const InputDecoration(
                hintText: 'Enter room ID',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            const Text('Your Name', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(labelText: 'Your Name', border: OutlineInputBorder()),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: joining ? null : _joinRoom,
                icon: joining ? 
                  SizedBox(
                    width: 16, 
                    height: 16,
                    child: CircularProgressIndicator(
                      color: Colors.white,
                      strokeWidth: 2,
                    )
                  ) : const Icon(Icons.login),
                label: Text(joining ? 'Connecting...' : 'Join Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ] else ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _leaveRoom,
                icon: const Icon(Icons.logout),
                label: const Text('Leave Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Colors.red,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ],
          
          const SizedBox(height: 20),
          
          Expanded(
            child: showDiagnosticPanel
                ? _buildDiagnosticPanel()
                : _buildChatTranscript(),
          ),
          
          if (joined) _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildChatTranscript() {
    return Card(
      margin: EdgeInsets.zero,
      color: showDiagnosticPanel
            ? Theme.of(context).colorScheme.primary
            : Theme.of(context).colorScheme.surface,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
            color: showDiagnosticPanel
                ? Theme.of(context).colorScheme.primary
                : Theme.of(context).colorScheme.surface,
            child: Row(
              children: [
                Text(
                  'Chat Transcript',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: showDiagnosticPanel
                        ? Theme.of(context).colorScheme.onPrimary.withOpacity(0.7)
                        : Theme.of(context).colorScheme.onSurface,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.code),
                  tooltip: 'Show Diagnostics',
                  color: showDiagnosticPanel
                      ? Theme.of(context).colorScheme.onPrimary
                      : Theme.of(context).colorScheme.onSurface,
                  onPressed: () {
                    setState(() => showDiagnosticPanel = true);
                  },
                ),
              ],
            ),
          ),
          Expanded(
            child: ListView.builder(
              controller: transcriptController,
              itemCount: messages.length,
              itemBuilder: (context, index) {
                final message = messages[index];
                return ListTile(
                  title: Text(message.text),
                  subtitle: Text(message.sender),
                  dense: true,
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInputArea() {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: inputController,
              decoration: const InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            onPressed: _sendMessage,
            icon: const Icon(Icons.send),
            style: IconButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.primary,
              foregroundColor: Colors.white,
            ),
          ),
          IconButton(
            onPressed: _toggleMic,
            icon: Icon(micOn ? Icons.mic : Icons.mic_off),
            style: IconButton.styleFrom(
              backgroundColor: micOn ? Colors.red : Colors.grey.shade700,
              foregroundColor: Colors.white,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDiagnosticPanel() {
    return Card(
      margin: EdgeInsets.zero,
      color: Colors.black87,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
            color: Colors.black,
            child: Row(
              children: [
                const Text(
                  'Diagnostic Logs',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: Colors.white70,
                  ),
                ),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  color: Colors.white70,
                  onPressed: () => setState(() => showDiagnosticPanel = false),
                ),
              ],
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              controller: diagnosticController,
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: SelectableText(
                  diagnosticLogs.join('\n'),
                  style: const TextStyle(
                    fontFamily: 'monospace',
                    fontSize: 12,
                    color: Colors.greenAccent,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [Color(0xFF3366FF), Color(0xFF00CCFF)],
          ),
        ),
        child: SafeArea(
          child: Row(
            children: [
              // Left sidebar
              Container(
                width: 200,
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
                color: Colors.black45,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('ðŸŽ§ HearAll', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
                    const SizedBox(height: 24),
                    
                    if (joined) ...[
                      const Text('PARTICIPANTS', style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
                      const SizedBox(height: 8),
                      Expanded(
                        flex: 2,
                        child: ListView.builder(
                          itemCount: participants.length,
                          itemBuilder: (context, index) {
                            return Padding(
                              padding: const EdgeInsets.symmetric(vertical: 4.0),
                              child: Text('ðŸ‘¤ ${participants[index]}', style: const TextStyle(color: Colors.white)),
                            );
                          },
                        ),
                      ),
                    ],
                    
                    const Divider(color: Colors.white24),
                    _buildSidebarButton(icon: Icons.chat, label: 'Chat', isSelected: true, onTap: () {}),
                    _buildSidebarButton(
                      icon: Icons.share, 
                      label: 'Share', 
                      onTap: () {
                        Clipboard.setData(ClipboardData(text: 'Join my HearAll room: ${roomController.text}'));
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Room ID copied to clipboard!'))
                        );
                      }
                    ),
                    _buildSidebarButton(
                      icon: Icons.settings, 
                      label: 'Settings', 
                      onTap: () {
                        // TODO: Implement settings
                      }
                    ),
                  ],
                ),
              ),
              
              // Main content area
              _buildMainContent(),
            ],
          ),
        ),
      ),
    );
  }
  
  /// Verify that required JavaScript files are loaded
  void _verifyJavaScriptLoaded() {
    final hasWebRTC = js.context.hasProperty('webrtcJoin');
    
    if (!hasWebRTC) {
      _addDiagnosticLog('[error] Required JavaScript files not loaded: webrtc_helper.js');
      
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('JavaScript Files Not Loaded'),
            content: const Text(
              'The application cannot connect to the server correctly. This may be because:\n\n'
              '1. The server is not running\n'
              '2. The JavaScript files failed to load\n\n'
              'Please check that the server is running on http://localhost:3000 and refresh the page.'
            ),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: const Text('OK'),
              ),
            ],
          );
        },
      );
    } else {
      _addDiagnosticLog('[system] JavaScript helpers verified');
    }
  }
}
