import 'dart:async';
import 'dart:html' as html;
import 'dart:js' as js;
import 'dart:js_util' as js_util;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;

void main() {
  runApp(const MyApp());
}

const String SERVER_BASE = String.fromEnvironment('SERVER_BASE', defaultValue: 'http://localhost:3000');

class ChatMessage {
  final String sender;
  final String text;
  final bool isSystem;
  final DateTime timestamp;

  ChatMessage({
    required this.sender,
    required this.text,
    this.isSystem = false,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'HearAll',
      theme: ThemeData(
        brightness: Brightness.dark,
        primaryColor: const Color(0xFF3498db),
        scaffoldBackgroundColor: const Color(0xFF1e1e1e),
        colorScheme: ColorScheme.dark(
          primary: const Color(0xFF3498db),
          secondary: const Color(0xFF2ecc71),
          background: const Color(0xFF1e1e1e),
          surface: const Color(0xFF2c3e50),
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onBackground: Colors.white,
          onSurface: Colors.white,
        ),
        textTheme: const TextTheme(
          bodyMedium: TextStyle(color: Colors.white),
        ),
        dialogBackgroundColor: const Color(0xFF2a2a2a),
      ),
      home: const HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  // Controllers
  final TextEditingController roomController = TextEditingController();
  final TextEditingController nameController = TextEditingController();
  final TextEditingController inputController = TextEditingController();
  final ScrollController transcriptController = ScrollController();
  final ScrollController diagnosticController = ScrollController();

  // State variables
  bool joined = false;
  bool joining = false;
  bool micOn = false;
  bool isRecording = false;
  bool audioPermissionGranted = false;
  bool hasRequestedMicPermission = false;
  bool showDiagnosticPanel = false;
  
  // Data lists
  List<String> transcriptLines = [];
  List<String> diagnosticLogs = [];
  List<String> participants = [];
  List<ChatMessage> messages = [];

  // WebRTC objects
  dynamic webrtcConn;
  dynamic ttsHandler;

  @override
  void initState() {
    super.initState();
    
    // Register JavaScript callbacks
    _registerJsCallbacks();
    
    // Request microphone permission on load
    _requestMicPermissionOnStartup();
    _initializeWebRTC();
    
    // Verify JavaScript files are loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _verifyJavaScriptLoaded();
    });
  }
  
  void _registerJsCallbacks() {
    // Register connection established callback
    js.context['dartConnectionEstablished'] = () {
      setState(() {
        joined = true;
        joining = false;
      });
      _addDiagnosticLog('[system] Connection established');
      _addTranscriptMessage('[system] Connected to chat room');
    };
    
    // Register connection closed callback
    js.context['dartConnectionClosed'] = () {
      setState(() {
        joined = false;
        joining = false;
        micOn = false;
        participants.clear();
      });
      _addDiagnosticLog('[system] Connection closed');
      _addTranscriptMessage('[system] Disconnected from chat room');
    };
    
    // Register participant update callback
    js.context['dartUpdateParticipants'] = (dynamic participantList) {
      final List<String> newParticipants = List<String>.from(participantList);
      setState(() {
        participants = newParticipants;
      });
      _addDiagnosticLog('[webrtc] Participants updated: ${participants.join(', ')}');
    };
  }

  @override
  void dispose() {
    roomController.dispose();
    nameController.dispose();
    inputController.dispose();
    transcriptController.dispose();
    diagnosticController.dispose();
    webrtcConn?.callMethod('leave');
    super.dispose();
  }

  Future<void> _requestMicPermissionOnStartup() async {
    if (hasRequestedMicPermission) return;
    setState(() => hasRequestedMicPermission = true);
    
    try {
      await html.window.navigator.mediaDevices?.getUserMedia({'audio': true});
      setState(() => audioPermissionGranted = true);
      _addDiagnosticLog('[system] Microphone permission granted.');
    } catch (e) {
      setState(() => audioPermissionGranted = false);
      _addDiagnosticLog('[error] Microphone permission denied. Please grant permission and refresh.');
    }
  }

  Future<void> _initializeWebRTC() async {
    try {
      ttsHandler = js_util.callConstructor(
        js_util.getProperty(html.window, 'TTSHandler'),
        [SERVER_BASE]
      );
      _addDiagnosticLog('[system] Audio systems initialized.');
    } catch (e) {
      _addDiagnosticLog('[error] Failed to initialize audio: $e');
    }
  }

  void _addLog(String message, {bool isDiagnostic = false}) {
    setState(() {
      final timestamp = DateTime.now().toString().split('.')[0];
      final logLine = '$timestamp: $message';
      if (isDiagnostic) {
        diagnosticLogs.add(logLine);
      } else {
        transcriptLines.add(logLine);
      }
    });

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!isDiagnostic && transcriptController.hasClients) {
        transcriptController.jumpTo(transcriptController.position.maxScrollExtent);
      } else if (isDiagnostic && diagnosticController.hasClients) {
        diagnosticController.jumpTo(diagnosticController.position.maxScrollExtent);
      }
    });
  }

  void _addTranscriptMessage(String message) => _addLog(message);
  void _addDiagnosticLog(String message) => _addLog(message, isDiagnostic: true);

  Future<void> _joinRoom() async {
    if (roomController.text.isEmpty || nameController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter both room ID and name')),
      );
      return;
    }

    if (!audioPermissionGranted) {
      _addDiagnosticLog('[error] Join failed: Microphone permission not granted.');
      _requestMicPermissionOnStartup();
      return;
    }

    setState(() {
      joining = true;
    });
    
    try {
      // First check if the server is reachable
      try {
        final response = await http.get(Uri.parse('$SERVER_BASE/'));
        _addDiagnosticLog('[server] Connection test: ${response.statusCode == 200 ? "OK" : "Failed: ${response.statusCode}"}');
      } catch (e) {
        _addDiagnosticLog('[error] Server connection failed: $e');
        _addTranscriptMessage('[error] Could not connect to server. Is it running?');
        setState(() {
          joining = false;
        });
        return;
      }
      
      _addDiagnosticLog('[webrtc] Attempting to join room: ${roomController.text}');
      
      // Make sure the JavaScript function is available
      if (!js.context.hasProperty('webrtcJoin')) {
        _addDiagnosticLog('[error] webrtcJoin function not found');
        _addTranscriptMessage('[error] WebRTC helper not loaded. Please check the console.');
        setState(() {
          joining = false;
        });
        return;
      }
      
      // Use JavaScript interop with the global webrtcJoin function
      try {
        final result = js.context.callMethod('webrtcJoin', [
          roomController.text,
          nameController.text
        ]);
        
        _addDiagnosticLog('[webrtc] Join attempt result: $result');
        
        if (result == null || result == false) {
          _addDiagnosticLog('[error] webrtcJoin failed');
          _addTranscriptMessage('[error] Failed to join room. Check console for details.');
          setState(() {
            joining = false;
          });
          return;
        }
        
        // The onStateChange callback will be handled by dartConnectionEstablished function
        _addTranscriptMessage('[system] Joining room ${roomController.text}... please wait');
      } catch (e) {
        _addDiagnosticLog('[error] Exception calling webrtcJoin: $e');
        _addTranscriptMessage('[error] Failed to join room: $e');
        setState(() {
          joining = false;
        });
        return;
      }
    } catch (e) {
      _addDiagnosticLog('[error] Join room error: $e');
      setState(() {
        joining = false;
      });
      setState(() {
        joined = false;
        micOn = false;
            participants.clear();
          });
          _addTranscriptMessage('[system] Disconnected from room.');
        }
      }));
      js_util.setProperty(webrtcConn, 'onParticipantsUpdate', js.allowInterop((dynamic newParticipants) {
        setState(() {
          participants = (newParticipants as List).cast<String>();
          _addDiagnosticLog('[webrtc] Participants updated: $participants');
        });
      }));

      await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'join', []));
    } catch (e) {
      _addTranscriptMessage('[error] Failed to join room: $e');
      _addDiagnosticLog('[error] Failed to join room: $e');
    }
  }

  Future<void> _leaveRoom() async {
    setState(() {
      joining = true;
    });
    
    try {
      _addDiagnosticLog('[webrtc] Attempting to leave room');
      
      if (!js.context.hasProperty('webrtcLeave')) {
        _addDiagnosticLog('[error] webrtcLeave function not found');
        _addTranscriptMessage('[error] WebRTC helper not loaded. Disconnecting locally.');
        setState(() {
          joined = false;
          joining = false;
          micOn = false;
        });
        return;
      }
      
      final result = js.context.callMethod('webrtcLeave', []);
      _addDiagnosticLog('[webrtc] Leave result: $result');
      
      // The connection closed callback will handle the state updates
      
    } catch (e) {
      _addDiagnosticLog('[error] Error leaving room: $e');
      _addTranscriptMessage('[error] Error leaving room: $e');
      setState(() {
        joining = false;
      });
    }
  }

  void _handleWebRTCMessage(dynamic message) {
    if (message == null) return;
    try {
      final type = js_util.getProperty(message, 'type');
      final data = js_util.getProperty(message, 'data');
      final user = js_util.getProperty(message, 'user') ?? 'System';
      
      _addDiagnosticLog('[webrtc] Received message type: $type from $user');

      switch (type) {
        case 'transcript':
          _addTranscriptMessage('(You) $data');
          break;
        case 'tts':
          _addTranscriptMessage('($user) $data');
          _playTTS(data as String);
          break;
        case 'chat':
          final chatMessage = ChatMessage(text: data as String, sender: user, isSystem: false);
          setState(() {
            messages.add(chatMessage);
          });
          _addTranscriptMessage('($user) $data');
          _playTTS(data);
          break;
        case 'error':
          _addTranscriptMessage('[error] $data');
          _addDiagnosticLog('[error] $data');
          break;
      }
    } catch (e) {
      _addTranscriptMessage('[error] Failed to handle message: $e');
      _addDiagnosticLog('[error] Failed to handle message: $e');
    }
  }

  Future<void> _playTTS(String text) async {
    try {
      if (ttsHandler != null) {
        _addDiagnosticLog('[tts] Attempting to speak: "$text"');
        await js_util.promiseToFuture(
          js_util.callMethod(ttsHandler, 'speak', [text, 'Alloy'])
        );
        _addDiagnosticLog('[tts] Finished speaking.');
      }
    } catch (e) {
      _addTranscriptMessage('[error] TTS synthesis failed: $e');
      _addDiagnosticLog('[error] TTS synthesis failed: $e');
    }
  }

  Future<void> _toggleMic() async {
    if (!joined) return;
    
    setState(() => micOn = !micOn);
    try {
      if (micOn) {
        await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'startAudio', []));
        _addTranscriptMessage('[system] Microphone ON.');
        _addDiagnosticLog('[audio] Microphone started.');
      } else {
        await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'stopAudio', []));
        _addTranscriptMessage('[system] Microphone OFF.');
        _addDiagnosticLog('[audio] Microphone stopped.');
      }
    } catch (e) {
      _addTranscriptMessage('[error] Mic toggle failed: $e');
      _addDiagnosticLog('[error] Mic toggle failed: $e');
      setState(() => micOn = !micOn); // Revert state on error
    }
  }

  void _sendMessage() {
    if (inputController.text.isNotEmpty && webrtcConn != null) {
      final text = inputController.text;
      js_util.callMethod(webrtcConn, 'sendChat', [text]);
      setState(() {
        messages.add(ChatMessage(text: text, sender: 'Me', isSystem: false));
      });
      _addTranscriptMessage('(You) $text');
      inputController.clear();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          Expanded(
            child: Row(
              children: [
                _buildSidebar(),
                _buildMainContent(),
              ],
            ),
          ),
          if (showDiagnosticPanel) _buildDiagnosticPanel(),
        ],
      ),
    );
  }

  Widget _buildSidebar() {
    return Container(
      width: 240,
      color: const Color(0xFF2c3e50),
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('ðŸŽ§ HearAll', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
          const SizedBox(height: 24),
          
          if (joined) ...[
            const Text('PARTICIPANTS', style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Expanded(
              flex: 2,
              child: ListView.builder(
                itemCount: participants.length,
                itemBuilder: (context, index) {
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4.0),
                    child: Text('ðŸ‘¤ ${participants[index]}', style: const TextStyle(color: Colors.white)),
                  );
                },
              ),
            ),
          ],
          
          const Divider(color: Colors.white24),
          _buildSidebarButton(icon: Icons.chat, label: 'Chat', isSelected: true, onTap: () {}),
          _buildSidebarButton(
            icon: Icons.share, 
            label: 'Share', 
            onTap: () {
              Clipboard.setData(ClipboardData(text: 'Join my HearAll room: ${roomController.text}'));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Room ID copied to clipboard!'))
              );
            }
          ),
          _buildSidebarButton(
            icon: Icons.settings, 
            label: 'Settings', 
            onTap: () {
              setState(() {
                showDiagnosticPanel = !showDiagnosticPanel;
              });
            }
          ),
          
          const Spacer(),
          
          if (!joined) ...[
            TextField(
              controller: roomController,
              decoration: const InputDecoration(labelText: 'Room ID', border: OutlineInputBorder()),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(labelText: 'Your Name', border: OutlineInputBorder()),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: joining ? null : _joinRoom,
                icon: joining ? 
                  SizedBox(
                    width: 16, 
                    height: 16,
                    child: CircularProgressIndicator(
                      color: Colors.white,
                      strokeWidth: 2,
                    )
                  ) : const Icon(Icons.login),
                label: Text(joining ? 'Connecting...' : 'Join Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ] else ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _leaveRoom,
                icon: const Icon(Icons.logout),
                label: const Text('Leave Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Colors.red,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildSidebarButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    bool isSelected = false
  }) {
    return Material(
      color: isSelected ? Colors.black.withOpacity(0.2) : Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          child: Row(
            children: [
              Icon(icon, color: Colors.white),
              const SizedBox(width: 12),
              Text(label, style: const TextStyle(color: Colors.white, fontSize: 16)),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainContent() {
    return Expanded(
      child: Column(
        children: [
          Expanded(
            child: Container(
              padding: const EdgeInsets.all(16.0),
              child: ListView.builder(
                controller: transcriptController,
                itemCount: messages.length,
                itemBuilder: (context, index) {
                  final message = messages[index];
                  return _buildMessageBubble(message);
                },
              ),
            ),
          ),
          if (joined) _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message) {
    final isMe = message.sender == 'Me';
    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
        padding: const EdgeInsets.all(12.0),
        decoration: BoxDecoration(
          color: isMe 
            ? Theme.of(context).colorScheme.primary
            : Theme.of(context).colorScheme.surface,
          borderRadius: BorderRadius.circular(12.0),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              message.sender,
              style: TextStyle(
                fontSize: 12.0,
                color: isMe
                  ? Theme.of(context).colorScheme.onPrimary.withOpacity(0.7)
                  : Theme.of(context).colorScheme.onSurface.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 4.0),
            Text(
              message.text,
              style: TextStyle(
                color: isMe
                  ? Theme.of(context).colorScheme.onPrimary
                  : Theme.of(context).colorScheme.onSurface,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInputArea() {
    return Container(
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: const Color(0xFF2c3e50),
        border: Border(top: BorderSide(color: Colors.black.withOpacity(0.2))),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: inputController,
              decoration: const InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(),
                filled: true,
                fillColor: Color(0xFF1e1e1e),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.send),
            onPressed: _sendMessage,
            style: IconButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.primary,
              foregroundColor: Colors.white,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: Icon(micOn ? Icons.mic : Icons.mic_off),
            onPressed: _toggleMic,
            style: IconButton.styleFrom(
              backgroundColor: micOn ? Colors.red : Colors.grey.shade700,
              foregroundColor: Colors.white,
            ),
            iconSize: 24,
          ),
        ],
      ),
    );
  }

  Widget _buildDiagnosticPanel() {
    return Container(
      height: 200,
      padding: const EdgeInsets.all(8.0),
      decoration: BoxDecoration(
        color: const Color(0xFF1e1e1e),
        border: Border(top: BorderSide(color: Colors.black.withOpacity(0.2))),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text('Diagnostic Panel',
                style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => setState(() => showDiagnosticPanel = false),
                color: Colors.white70,
              ),
            ],
          ),
          Expanded(
            child: ListView.builder(
              controller: diagnosticController,
              itemCount: diagnosticLogs.length,
              itemBuilder: (context, index) {
                final log = diagnosticLogs[index];
                Color color = Colors.white70;
                if (log.contains('[error]')) color = Colors.red;
                if (log.contains('[system]')) color = Colors.cyan;
                if (log.contains('[webrtc]')) color = Colors.orange;
                if (log.contains('[audio]')) color = Colors.green;
                if (log.contains('[tts]')) color = Colors.purple;
                
                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 2.0),
                  child: Text(log,
                    style: TextStyle(
                      color: color,
                      fontFamily: 'monospace',
                      fontSize: 12,
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
    / / /   V e r i f y   t h a t   r e q u i r e d   J a v a S c r i p t   f i l e s   a r e   l o a d e d 
     v o i d   _ v e r i f y J a v a S c r i p t L o a d e d ( )   { 
         f i n a l   h a s W e b R T C   =   j s . c o n t e x t . h a s P r o p e r t y ( \ " w e b r t c J o i n \ " ) ; 
         
         i f   ( ! h a s W e b R T C )   { 
             _ a d d D i a g n o s t i c L o g ( \ " [ e r r o r ]   R e q u i r e d   J a v a S c r i p t   f i l e s   n o t   l o a d e d :   w e b r t c _ h e l p e r . j s \ " ) ; 
             
             s h o w D i a l o g ( 
                 c o n t e x t :   c o n t e x t , 
                 b a r r i e r D i s m i s s i b l e :   f a l s e , 
                 b u i l d e r :   ( B u i l d C o n t e x t   c o n t e x t )   { 
                     r e t u r n   A l e r t D i a l o g ( 
                         t i t l e :   c o n s t   T e x t ( \ " J a v a S c r i p t   F i l e s   N o t   L o a d e d \ " ) , 
                         c o n t e n t :   c o n s t   T e x t ( 
                             \ " T h e   a p p l i c a t i o n   c a n n o t   c o n n e c t   t o   t h e   s e r v e r   c o r r e c t l y .   T h i s   m a y   b e   b e c a u s e : \ \ n \ \ n \ " 
                             \ " 1 .   T h e   s e r v e r   i s   n o t   r u n n i n g \ \ n \ " 
                             \ " 2 .   T h e   J a v a S c r i p t   f i l e s   f a i l e d   t o   l o a d \ \ n \ \ n \ " 
                             \ " P l e a s e   c h e c k   t h a t   t h e   s e r v e r   i s   r u n n i n g   o n   h t t p : / / l o c a l h o s t : 3 0 0 0   a n d   r e f r e s h   t h e   p a g e . \ " 
                         ) , 
                         a c t i o n s :   [ 
                             T e x t B u t t o n ( 
                                 o n P r e s s e d :   ( )   { 
                                     N a v i g a t o r . o f ( c o n t e x t ) . p o p ( ) ; 
                                 } , 
                                 c h i l d :   c o n s t   T e x t ( \ " O K \ " ) , 
                             ) , 
                         ] , 
                     ) ; 
                 } , 
             ) ; 
         }   e l s e   { 
             _ a d d D i a g n o s t i c L o g ( \ " [ s y s t e m ]   J a v a S c r i p t   h e l p e r s   v e r i f i e d \ " ) ; 
         } 
     }  
 