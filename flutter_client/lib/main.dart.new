import 'dart:async';
import 'dart:html' as html;
import 'dart:js' as js;
import 'dart:js_util' as js_util;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void main() {
  runApp(const MyApp());
}

const String SERVER_BASE = String.fromEnvironment('SERVER_BASE', defaultValue: 'http://localhost:3000');

class ChatMessage {
  final String message;
  final String user;
  final bool isMe;
  
  ChatMessage({required this.message, required this.user, required this.isMe});
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'HearAll',
      theme: ThemeData(
        brightness: Brightness.dark,
        primaryColor: const Color(0xFF3498db),
        scaffoldBackgroundColor: const Color(0xFF1e1e1e),
        colorScheme: const ColorScheme.dark(
          primary: Color(0xFF3498db),
          secondary: Color(0xFF2ecc71),
          background: Color(0xFF1e1e1e),
          surface: Color(0xFF2c3e50),
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onBackground: Colors.white,
          onSurface: Colors.white,
        ),
        textTheme: const TextTheme(
          bodyMedium: TextStyle(color: Colors.white),
        ),
        dialogBackgroundColor: const Color(0xFF2a2a2a),
      ),
      home: const HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  // Controllers
  final TextEditingController roomController = TextEditingController();
  final TextEditingController nameController = TextEditingController();
  final TextEditingController inputController = TextEditingController();
  final ScrollController transcriptController = ScrollController();
  final ScrollController diagnosticController = ScrollController();

  // State variables
  bool joined = false;
  bool micOn = false;
  bool isRecording = false;
  bool audioPermissionGranted = false;
  bool hasRequestedMicPermission = false;
  bool showDiagnosticPanel = false;
  
  // Data lists
  List<String> transcriptLines = [];
  List<String> diagnosticLogs = [];
  List<String> participants = [];

  // WebRTC objects
  dynamic webrtcConn;
  dynamic ttsHandler;

  @override
  void initState() {
    super.initState();
    _requestMicPermissionOnStartup();
    _initializeWebRTC();
  }

  @override
  void dispose() {
    roomController.dispose();
    nameController.dispose();
    inputController.dispose();
    transcriptController.dispose();
    diagnosticController.dispose();
    webrtcConn?.callMethod('leave');
    super.dispose();
  }

  Future<void> _requestMicPermissionOnStartup() async {
    if (hasRequestedMicPermission) return;
    setState(() => hasRequestedMicPermission = true);
    
    try {
      await html.window.navigator.mediaDevices?.getUserMedia({'audio': true});
      setState(() => audioPermissionGranted = true);
      _addDiagnosticLog('[system] Microphone permission granted.');
    } catch (e) {
      setState(() => audioPermissionGranted = false);
      _addDiagnosticLog('[error] Microphone permission denied. Please grant permission and refresh.');
    }
  }

  Future<void> _initializeWebRTC() async {
    try {
      ttsHandler = js_util.callConstructor(
        js_util.getProperty(html.window, 'TTSHandler'),
        [SERVER_BASE]
      );
      _addDiagnosticLog('[system] Audio systems initialized.');
    } catch (e) {
      _addDiagnosticLog('[error] Failed to initialize audio: $e');
    }
  }

  void _addLog(String message, {bool isDiagnostic = false}) {
    setState(() {
      final timestamp = DateTime.now().toString().split('.')[0];
      final logLine = '$timestamp: $message';
      if (isDiagnostic) {
        diagnosticLogs.add(logLine);
      } else {
        transcriptLines.add(logLine);
      }
    });

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!isDiagnostic && transcriptController.hasClients) {
        transcriptController.jumpTo(transcriptController.position.maxScrollExtent);
      } else if (isDiagnostic && diagnosticController.hasClients) {
        diagnosticController.jumpTo(diagnosticController.position.maxScrollExtent);
      }
    });
  }

  void _addTranscriptMessage(String message) => _addLog(message);
  void _addDiagnosticLog(String message) => _addLog(message, isDiagnostic: true);

  Future<void> _joinRoom() async {
    if (roomController.text.isEmpty || nameController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter both room ID and name')),
      );
      return;
    }

    if (!audioPermissionGranted) {
      _addDiagnosticLog('[error] Join failed: Microphone permission not granted.');
      _requestMicPermissionOnStartup();
      return;
    }

    try {
      final mediaConstraints = js_util.jsify({'audio': true, 'video': false});
      webrtcConn = js_util.callConstructor(
        js_util.getProperty(html.window, 'WebRTCConnection'),
        [roomController.text, nameController.text, mediaConstraints]
      );

      js_util.setProperty(webrtcConn, 'onMessage', js.allowInterop(_handleWebRTCMessage));
      js_util.setProperty(webrtcConn, 'onStateChange', js.allowInterop((String state) {
        _addDiagnosticLog('[webrtc] Connection state: $state');
        if (state == 'connected') {
          setState(() => joined = true);
          _addTranscriptMessage('[system] Connected to room: ${roomController.text}');
        } else if (state == 'disconnected') {
          setState(() {
            joined = false;
            micOn = false;
            participants.clear();
          });
          _addTranscriptMessage('[system] Disconnected from room.');
        }
      }));
      js_util.setProperty(webrtcConn, 'onParticipantsUpdate', js.allowInterop((dynamic newParticipants) {
        setState(() {
          participants = (newParticipants as List).cast<String>();
          _addDiagnosticLog('[webrtc] Participants updated: $participants');
        });
      }));

      await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'join', []));
    } catch (e) {
      _addTranscriptMessage('[error] Failed to join room: $e');
      _addDiagnosticLog('[error] Failed to join room: $e');
    }
  }

  Future<void> _leaveRoom() async {
    try {
      if (webrtcConn != null) {
        await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'leave', []));
      }
    } catch (e) {
      _addTranscriptMessage('[error] Error leaving room: $e');
      _addDiagnosticLog('[error] Error leaving room: $e');
    }
  }

  void _handleWebRTCMessage(dynamic message) {
    if (message == null) return;
    try {
      final type = js_util.getProperty(message, 'type');
      final data = js_util.getProperty(message, 'data');
      final user = js_util.getProperty(message, 'user') ?? 'System';
      
      _addDiagnosticLog('[webrtc] Received message type: $type from $user');

      switch (type) {
        case 'transcript':
          _addTranscriptMessage('(You) $data');
          break;
        case 'tts':
          _addTranscriptMessage('($user) $data');
          _playTTS(data as String);
          break;
        case 'chat':
          _addTranscriptMessage('($user) $data');
          _playTTS(data as String);
          break;
        case 'error':
          _addTranscriptMessage('[error] $data');
          _addDiagnosticLog('[error] $data');
          break;
      }
    } catch (e) {
      _addTranscriptMessage('[error] Failed to handle message: $e');
      _addDiagnosticLog('[error] Failed to handle message: $e');
    }
  }

  Future<void> _playTTS(String text) async {
    try {
      if (ttsHandler != null) {
        _addDiagnosticLog('[tts] Attempting to speak: "$text"');
        await js_util.promiseToFuture(
          js_util.callMethod(ttsHandler, 'speak', [text, 'Alloy'])
        );
        _addDiagnosticLog('[tts] Finished speaking.');
      }
    } catch (e) {
      _addTranscriptMessage('[error] TTS synthesis failed: $e');
      _addDiagnosticLog('[error] TTS synthesis failed: $e');
    }
  }

  Future<void> _toggleMic() async {
    if (!joined) return;
    
    setState(() => micOn = !micOn);
    try {
      if (micOn) {
        await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'startAudio', []));
        _addTranscriptMessage('[system] Microphone ON.');
        _addDiagnosticLog('[audio] Microphone started.');
      } else {
        await js_util.promiseToFuture(js_util.callMethod(webrtcConn, 'stopAudio', []));
        _addTranscriptMessage('[system] Microphone OFF.');
        _addDiagnosticLog('[audio] Microphone stopped.');
      }
    } catch (e) {
      _addTranscriptMessage('[error] Mic toggle failed: $e');
      _addDiagnosticLog('[error] Mic toggle failed: $e');
      setState(() => micOn = !micOn); // Revert state on error
    }
  }

  void _sendMessage() {
    if (inputController.text.isNotEmpty && webrtcConn != null) {
      final text = inputController.text;
      js_util.callMethod(webrtcConn, 'sendChat', [text]);
      _addTranscriptMessage('(You) $text');
      inputController.clear();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          Expanded(
            child: Row(
              children: [
                _buildSidebar(),
                _buildMainContent(),
              ],
            ),
          ),
          if (showDiagnosticPanel) _buildDiagnosticPanel(),
        ],
      ),
    );
  }

  Widget _buildSidebar() {
    return Container(
      width: 240,
      color: const Color(0xFF2c3e50),
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('ðŸŽ§ HearAll', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.white)),
          const SizedBox(height: 24),
          
          if (joined) ...[
            const Text('PARTICIPANTS', style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Expanded(
              flex: 2,
              child: ListView.builder(
                itemCount: participants.length,
                itemBuilder: (context, index) {
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4.0),
                    child: Text('ðŸ‘¤ ${participants[index]}', style: const TextStyle(color: Colors.white)),
                  );
                },
              ),
            ),
          ],
          
          const Divider(color: Colors.white24),
          _buildSidebarButton(icon: Icons.chat, label: 'Chat', isSelected: true, onTap: () {}),
          _buildSidebarButton(
            icon: Icons.help_outline, 
            label: 'Help', 
            onTap: () {
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: const Text('Instructions'),
                  content: const SingleChildScrollView(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Welcome to HearAll!'),
                        SizedBox(height: 16),
                        Text('1. Enter a Room ID and your name to join'),
                        Text('2. Click the microphone button to toggle voice input'),
                        Text('3. Type messages in the input field and press send'),
                        Text('4. Click the diagnostic panel toggle to see technical details'),
                      ],
                    ),
                  ),
                  actions: [
                    TextButton(
                      child: const Text('Close'),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
              );
            }
          ),
          _buildSidebarButton(
            icon: Icons.share, 
            label: 'Share', 
            onTap: () {
              Clipboard.setData(ClipboardData(text: 'Join my HearAll room: ${roomController.text}'));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Room ID copied to clipboard!'))
              );
            }
          ),
          _buildSidebarButton(
            icon: Icons.settings, 
            label: 'Settings', 
            onTap: () {
              setState(() {
                showDiagnosticPanel = !showDiagnosticPanel;
              });
            }
          ),
          
          const Spacer(),
          
          if (!joined) ...[
            TextField(
              controller: roomController,
              decoration: const InputDecoration(labelText: 'Room ID', border: OutlineInputBorder()),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(labelText: 'Your Name', border: OutlineInputBorder()),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _joinRoom,
                icon: const Icon(Icons.login),
                label: const Text('Join Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ] else ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _leaveRoom,
                icon: const Icon(Icons.logout),
                label: const Text('Leave Room'),
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Colors.red,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildSidebarButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    bool isSelected = false
  }) {
    return Material(
      color: isSelected ? Colors.black.withOpacity(0.2) : Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 12.0, horizontal: 8.0),
          child: Row(
            children: [
              Icon(icon, color: Colors.white),
              const SizedBox(width: 12),
              Text(label, style: const TextStyle(color: Colors.white, fontSize: 16)),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainContent() {
    return Expanded(
      child: Column(
        children: [
          Expanded(
            child: Container(
              padding: const EdgeInsets.all(16.0),
              child: ListView.builder(
                controller: transcriptController,
                itemCount: transcriptLines.length,
                itemBuilder: (context, index) {
                  final line = transcriptLines[index];
                  Color color = Colors.white;
                  if (line.startsWith('[system]')) color = Colors.cyan;
                  if (line.startsWith('[error]')) color = Colors.redAccent;
                  if (line.startsWith('(You)')) color = Colors.lightGreenAccent;
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4.0),
                    child: Text(line, style: TextStyle(color: color, fontFamily: 'monospace')),
                  );
                },
              ),
            ),
          ),
          if (joined) _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildInputArea() {
    return Container(
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: const Color(0xFF2c3e50),
        border: Border(top: BorderSide(color: Colors.black.withOpacity(0.2))),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: inputController,
              decoration: const InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(),
                filled: true,
                fillColor: Color(0xFF1e1e1e),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.send),
            onPressed: _sendMessage,
            style: IconButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.primary,
              foregroundColor: Colors.white,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: Icon(micOn ? Icons.mic : Icons.mic_off),
            onPressed: _toggleMic,
            style: IconButton.styleFrom(
              backgroundColor: micOn ? Colors.red : Colors.grey.shade700,
              foregroundColor: Colors.white,
            ),
            iconSize: 24,
          ),
        ],
      ),
    );
  }

  Widget _buildDiagnosticPanel() {
    return Container(
      height: 200,
      padding: const EdgeInsets.all(8.0),
      decoration: BoxDecoration(
        color: const Color(0xFF1e1e1e),
        border: Border(top: BorderSide(color: Colors.black.withOpacity(0.2))),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text('Diagnostic Panel',
                style: TextStyle(color: Colors.white70, fontWeight: FontWeight.bold),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => setState(() => showDiagnosticPanel = false),
                color: Colors.white70,
              ),
            ],
          ),
          Expanded(
            child: ListView.builder(
              controller: diagnosticController,
              itemCount: diagnosticLogs.length,
              itemBuilder: (context, index) {
                final log = diagnosticLogs[index];
                Color color = Colors.white70;
                if (log.contains('[error]')) color = Colors.red;
                if (log.contains('[system]')) color = Colors.cyan;
                if (log.contains('[webrtc]')) color = Colors.orange;
                if (log.contains('[audio]')) color = Colors.green;
                if (log.contains('[tts]')) color = Colors.purple;
                
                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 2.0),
                  child: Text(log,
                    style: TextStyle(
                      color: color,
                      fontFamily: 'monospace',
                      fontSize: 12,
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
